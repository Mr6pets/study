<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>面向对象</title>
</head>
<body>
    <script>
        // 当new去调用一个函数：这个时候函数中的this就是创建出来的对象，而且函数的返回值直接就是this（隐式返回）
    /*
    工厂函数
    */
    // function creatFactory(name){
        // 1.原料
    //     var obj=new Object();
    //     2.加工
    //     obj.name=name;
    //     obj.showName=function(){
    //         alert(this.name);
    //     }
    //      3.出厂
    //     return obj;
    // }
    // var c1=creatFactory("小明");
    // c1.showName();//小明
    // var c2=creatFactory("领克");
    // c2.showName();

    // 构造函数
    // function CreatFactory(name){
    //     this.name=name;
    //     this.showName=function(){
    //         alert(this.name);
    //     };
    // }
    // var c1=new CreatFactory("小明");
    // c1.showName();
        // var a=5; 
        // var b=a;
        // b+=3;
        // console.log(b)//8
        // console.log(a)//5//基本类型：赋值的时候只是值的复制

        // var a=[1,2,3];
        // var b=a;
        // b.push(4);
        // console.log(b)//[1,2,3,4]
        // console.log(a)//[1,2,3,4]//对象基本类型；复制不仅是值的复制，而且也是引用的传递

        // var a=[1,2,3]
        // var b=a;
        // var b=[1,2,3,4];//这里是赋值操作 会在内存中重新生成 所以不会改变原a的数组；
        // confirm.log(b)//[1,2,3,4]
        // console.log(a)//[1,2,3]

        // var a=5;
        // var b=5;
        // alert(a==b);//true 基本类型比较 值相同就可以了

        // var a=[1,2,3];
        // var b=[1,2,3];
        // alert(a==b)//false 对象类型的比较就要比较值和引用头



    // 构造函数升级版本--原型
    //原型：去改写对象下面公用的方法和属性，让公用的方法和属性在内存中存在一份，用于提高程序的性能
    function CreatFactory(name){
        this.name=name;
    }
    CreatFactory.prototype.showName=function(){
        alert(this.name);
    }
    var c1=new CreatFactory("小明");
    c1.showName();//小明
    var c2=new CreatFactory("小里");
    c1.showName();//小里
    // console.log(c1.showName==c2.showName)//true

    </script>
</body>
</html>